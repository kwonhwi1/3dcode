MODULE SOLVE_MODULE
  USE CONFIG_MODULE
  USE EOS_MODULE
  USE PROP_MODULE
  USE GRID_MODULE
  USE VARIABLE_MODULE
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! SUBORDINATE TO UPDATE MODULE  
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  USE INITIAL_MODULE
  USE UPDATE_MODULE
  USE RESIDUAL_MODULE
  USE POST_MODULE
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC   
  IMPLICIT NONE
  PRIVATE
  PUBLIC :: T_SOLVE
  
  TYPE T_SOLVE
    PRIVATE
    LOGICAL :: L_UPDATE,L_NSTEADY,L_INI
    INTEGER :: NPV,NDV,IMAX,JMAX,KMAX
    INTEGER :: NPMAX,NTMAX,NEXPORT
    REAL(8) :: PREF
    CLASS(T_UPDATE), ALLOCATABLE :: UPDATE
    CLASS(T_INI), ALLOCATABLE :: INI
    CLASS(T_RESI), ALLOCATABLE :: RESI
    CLASS(T_POST), ALLOCATABLE :: POST
    CONTAINS
      PROCEDURE :: CONSTRUCT
      PROCEDURE :: DESTRUCT
      PROCEDURE :: SOLVE_EQUATION
      PROCEDURE,PRIVATE :: UNSTEADYUPDATE
  END TYPE T_SOLVE

  CONTAINS
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    SUBROUTINE CONSTRUCT(SOLVE,CONFIG,GRID,VARIABLE,EOS,PROP)
      IMPLICIT NONE
      CLASS(T_SOLVE), INTENT(OUT) :: SOLVE
      TYPE(T_CONFIG), INTENT(IN) :: CONFIG
      TYPE(T_GRID), INTENT(IN) :: GRID
      TYPE(T_VARIABLE), INTENT(IN) :: VARIABLE
      TYPE(T_EOS), INTENT(IN) :: EOS
      TYPE(T_PROP), INTENT(IN) :: PROP
      
      SOLVE%NPMAX = CONFIG%GETNPMAX()
      SOLVE%NTMAX = CONFIG%GETNTMAX()
      SOLVE%NEXPORT = CONFIG%GETNEXPORT()
      
      SOLVE%PREF = CONFIG%GETPREF()

      SOLVE%L_UPDATE = .FALSE.
      SOLVE%L_INI = .FALSE.
      
      SELECT CASE(CONFIG%GETTIMEMETHOD())
      CASE(1)
        ALLOCATE(T_EULEREX::SOLVE%UPDATE)
      CASE(2)
        ALLOCATE(T_RK3RD::SOLVE%UPDATE)
      CASE(3)
        ALLOCATE(T_LUSGS::SOLVE%UPDATE)
      END SELECT
      
      SELECT CASE(CONFIG%GETIREAD())
      CASE(0)
        ALLOCATE(T_INI_INITIAL::SOLVE%INI)
      CASE(1)
        ALLOCATE(T_INI_RESTART::SOLVE%INI)
      END SELECT
      
      SELECT CASE(CONFIG%GETNSTEADY())
      CASE(0)
        SOLVE%L_NSTEADY = .FALSE.
      CASE(1)
        SOLVE%L_NSTEADY = .TRUE.
      END SELECT
      
      IF(ALLOCATED(SOLVE%UPDATE)) THEN
        CALL SOLVE%UPDATE%CONSTRUCT(CONFIG,GRID,VARIABLE,EOS,PROP)
        SOLVE%L_UPDATE = .TRUE.
      END IF
      
      IF(ALLOCATED(SOLVE%INI)) THEN
        CALL SOLVE%INI%CONSTRUCT(CONFIG,GRID)
        SOLVE%L_INI = .TRUE.
      END IF
      
      ALLOCATE(SOLVE%RESI)
      CALL SOLVE%RESI%CONSTRUCT(CONFIG,GRID,VARIABLE)
      ALLOCATE(SOLVE%POST)
      CALL SOLVE%POST%CONSTRUCT(CONFIG,GRID,VARIABLE)
     
      SOLVE%IMAX = GRID%GETIMAX()
      SOLVE%JMAX = GRID%GETJMAX()
      SOLVE%KMAX = GRID%GETKMAX()
      SOLVE%NPV = VARIABLE%GETNPV()
      SOLVE%NDV = VARIABLE%GETNDV()
      
    END SUBROUTINE CONSTRUCT
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    SUBROUTINE DESTRUCT(SOLVE)
      IMPLICIT NONE
      CLASS(T_SOLVE), INTENT(INOUT) :: SOLVE
      
      IF(SOLVE%L_UPDATE) THEN
        CALL SOLVE%UPDATE%DESTRUCT()
        DEALLOCATE(SOLVE%UPDATE)
      END IF
      
      IF(SOLVE%L_INI) THEN
        CALL SOLVE%INI%DESTRUCT()
        DEALLOCATE(SOLVE%INI)
      END IF
      
      CALL SOLVE%RESI%DESTRUCT()
      DEALLOCATE(SOLVE%RESI)
      CALL SOLVE%POST%DESTRUCT()
      DEALLOCATE(SOLVE%POST)
      
    END SUBROUTINE DESTRUCT
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    SUBROUTINE SOLVE_EQUATION(SOLVE,GRID,VARIABLE,EOS,PROP)
      IMPLICIT NONE
      CLASS(T_SOLVE), INTENT(INOUT) :: SOLVE
      TYPE(T_GRID), INTENT(IN) :: GRID
      TYPE(T_VARIABLE), INTENT(INOUT) :: VARIABLE
      TYPE(T_EOS), INTENT(IN) :: EOS
      TYPE(T_PROP), INTENT(IN) :: PROP
      INTEGER :: NT_PHY,NT,NPS,NTS
      
      CALL SOLVE%INI%INITIALIZE(VARIABLE,EOS,PROP,NPS,NTS)
      
      DO NT_PHY=NPS,SOLVE%NPMAX
        DO NT=NTS,SOLVE%NTMAX
          CALL SOLVE%RESI%SETQRES(VARIABLE)
          CALL SOLVE%UPDATE%TIMEINTEG(GRID,VARIABLE,EOS,PROP)
          CALL SOLVE%RESI%RESIDUAL(VARIABLE,NT_PHY,NT)        
          IF(SOLVE%RESI%GETCONVERGE()) THEN
            CALL SOLVE%POST%EXPORT_VARIABLE(VARIABLE,NT_PHY,NT)
            EXIT
          END IF
          IF((MOD(NT,SOLVE%NEXPORT).EQ.0).AND.(.NOT.SOLVE%L_NSTEADY)) THEN
            CALL SOLVE%POST%EXPORT_VARIABLE(VARIABLE,NT_PHY,NT)
          END IF
        END DO
        IF(.NOT.SOLVE%L_NSTEADY) THEN
          CALL SOLVE%POST%EXPORT_VARIABLE(VARIABLE,NT_PHY,NT-1)
        END IF
        IF(SOLVE%L_NSTEADY) THEN
          IF(MOD(NT_PHY,SOLVE%NEXPORT).EQ.0) THEN
            CALL SOLVE%POST%EXPORT_VARIABLE(VARIABLE,NT_PHY,NT-1)
          END IF
          CALL SOLVE%UNSTEADYUPDATE(VARIABLE)
        END IF
      END DO
      
    END SUBROUTINE SOLVE_EQUATION
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    SUBROUTINE UNSTEADYUPDATE(SOLVE,VARIABLE)
      IMPLICIT NONE
      CLASS(T_SOLVE), INTENT(INOUT) :: SOLVE
      TYPE(T_VARIABLE), INTENT(INOUT) :: VARIABLE
      INTEGER :: I,J,K,N
      REAL(8) :: QQ(SOLVE%NPV),DV(SOLVE%NDV),PV(SOLVE%NPV)
      
      DO K=2,SOLVE%KMAX
        DO J=2,SOLVE%JMAX
          DO I=2,SOLVE%IMAX
            QQ = VARIABLE%GETQQ(1,I,J,K)
            CALL VARIABLE%SETQQ(2,I,J,K,QQ)
            DV = VARIABLE%GETDV(I,J,K)
            PV = VARIABLE%GETPV(I,J,K)
            QQ(1) = DV(1)
            QQ(2) = DV(1)*PV(2)
            QQ(3) = DV(1)*PV(3)
            QQ(4) = DV(1)*PV(4)
            QQ(5) = DV(1)*(DV(2)+0.5D0*(PV(2)**2+PV(3)**2+PV(4)**2))-PV(1)-SOLVE%PREF
            DO N=6,SOLVE%NPV
              QQ(N) = DV(1)*PV(N)
            END DO
            
            CALL VARIABLE%SETQQ(1,I,J,K,QQ)
            
          END DO
        END DO
      END DO
    END SUBROUTINE UNSTEADYUPDATE
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
END MODULE SOLVE_MODULE