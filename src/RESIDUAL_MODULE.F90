MODULE RESIDUAL_MODULE
  USE CONFIG_MODULE
  USE GRID_MODULE
  USE VARIABLE_MODULE
  IMPLICIT NONE
  PRIVATE
  PUBLIC :: T_RESI
  
  TYPE T_RESI
    PRIVATE
    LOGICAL :: L_CONVERGE
    INTEGER :: NPV,IMAX,JMAX
    INTEGER :: NTMAX,NPMAX,NPRINT
    INTEGER :: RANK,IO
    REAL(8) :: BOND
    REAL(8), DIMENSION(:,:,:), ALLOCATABLE :: QRES
    CONTAINS
      PROCEDURE :: CONSTRUCT
      PROCEDURE :: DESTRUCT
      PROCEDURE :: SETQRES
      PROCEDURE :: RESIDUAL
      PROCEDURE :: GETCONVERGE
  END TYPE T_RESI
  
  CONTAINS
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    SUBROUTINE CONSTRUCT(RESI,CONFIG,GRID,VARIABLE)
      IMPLICIT NONE
      CLASS(T_RESI), INTENT(OUT) :: RESI
      TYPE(T_CONFIG), INTENT(IN) :: CONFIG
      TYPE(T_GRID), INTENT(IN) :: GRID
      TYPE(T_VARIABLE), INTENT(IN) :: VARIABLE
      
      RESI%RANK = CONFIG%GETRANK()
      RESI%NPMAX = CONFIG%GETNPMAX()      
      RESI%NTMAX = CONFIG%GETNTMAX()
      RESI%IMAX = GRID%GETIMAX()
      RESI%JMAX = GRID%GETJMAX()
      RESI%NPV = VARIABLE%GETNPV()
      RESI%NPRINT = CONFIG%GETNPRINT()
      RESI%BOND = 10.D0**(-CONFIG%GETBOND())
      
      ALLOCATE(RESI%QRES(RESI%NPV,RESI%IMAX,RESI%JMAX))
      
      IF(CONFIG%GETIREAD().EQ.0) THEN
        IF(RESI%RANK.EQ.0) THEN
          OPEN(NEWUNIT=RESI%IO,FILE='./RES.PLT',STATUS='UNKNOWN',ACTION='WRITE')
          SELECT CASE(CONFIG%GETITURB())
          CASE(-1,0)
            WRITE(RESI%IO,*) 'VARIABLES="NT","RESP","RESU","RESV","REST","RESY1","RESY2","RESK","RESO"' 
          CASE(-2,-3)
            WRITE(RESI%IO,*) 'VARIABLES="NT","RESP","RESU","RESV","REST","RESY1","RESY2"' 
          END SELECT
        END IF
      ELSE !IREAD=1 RESTART
        IF(RESI%RANK.EQ.0) THEN
          OPEN(NEWUNIT=RESI%IO,FILE='./RES.PLT',STATUS='OLD',ACTION='WRITE',POSITION='APPEND')
        END IF
      END IF
      RESI%L_CONVERGE = .FALSE.
    END SUBROUTINE CONSTRUCT
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    SUBROUTINE DESTRUCT(RESI)
      IMPLICIT NONE
      CLASS(T_RESI), INTENT(INOUT) :: RESI
      
      IF(ALLOCATED(RESI%QRES)) DEALLOCATE(RESI%QRES)
      
      IF(RESI%RANK.EQ.0) THEN
        CLOSE(RESI%IO)
      END IF
      
    END SUBROUTINE DESTRUCT
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    SUBROUTINE SETQRES(RESI,VARIABLE)
      IMPLICIT NONE
      CLASS(T_RESI), INTENT(INOUT) :: RESI
      TYPE(T_VARIABLE), INTENT(IN) :: VARIABLE
      INTEGER :: I,J
      
      DO J=2,RESI%JMAX
        DO I=2,RESI%IMAX
          RESI%QRES(:,I,J) = VARIABLE%GETPV(I,J)
        END DO
      END DO
      
    END SUBROUTINE SETQRES
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    SUBROUTINE RESIDUAL(RESI,VARIABLE,NT_PHY,NT)
      IMPLICIT NONE
      INCLUDE 'mpif.h'
      CLASS(T_RESI), INTENT(INOUT) :: RESI
      TYPE(T_VARIABLE), INTENT(IN) :: VARIABLE
      INTEGER, INTENT(IN) :: NT_PHY,NT
      INTEGER :: I,J,N,IERR,ITER
      INTEGER :: IRESM,JRESM
      REAL(8) :: RESTEST,RESMAX
      REAL(8), DIMENSION(:) :: RES(RESI%NPV)
      REAL(8), DIMENSION(:) :: MPI_RES(RESI%NPV),MPI_RES_SUM(RESI%NPV)

      IF((RESI%RANK.EQ.0).AND.(NT.EQ.1).AND.(NT_PHY.EQ.1)) THEN
        WRITE(RESI%IO,*) 'ZONE T =" "'
      END IF
      
      RESMAX = 1.D-12
      RES = 0.D0
      
      DO J=2,RESI%JMAX
        DO I=2,RESI%IMAX
          RESI%QRES(:,I,J) = DABS(RESI%QRES(:,I,J) - VARIABLE%GETPV(I,J))
          DO N=1,RESI%NPV
            RES(N) = RES(N) + RESI%QRES(N,I,J)**2
          END DO
          RESTEST = RESI%QRES(1,I,J)
          IF(RESTEST.GT.RESMAX) THEN
            RESMAX = RESTEST
            IRESM=I
            JRESM=J
          END IF
        END DO
      END DO
      
      MPI_RES = RES
      CALL MPI_REDUCE(MPI_RES,MPI_RES_SUM,RESI%NPV,MPI_REAL8,MPI_SUM,0,MPI_COMM_WORLD,IERR)
      CALL MPI_BCAST(MPI_RES_SUM,RESI%NPV,MPI_REAL8,0,MPI_COMM_WORLD,IERR)
      
      DO N=1,RESI%NPV
        MPI_RES_SUM(N) = DSQRT(MPI_RES_SUM(N))
      END DO
      ITER = RESI%NTMAX*(NT_PHY-1)+NT
      IF(MOD(ITER,RESI%NPRINT).EQ.0) THEN
        IF(RESI%RANK.EQ.0) THEN
          IF(RESI%NPV.EQ.6) THEN
            WRITE(*,77) ITER, MPI_RES_SUM(1),MPI_RES_SUM(2),MPI_RES_SUM(3),MPI_RES_SUM(4),MPI_RES_SUM(5),MPI_RES_SUM(6)
          ELSE
            WRITE(*,99) ITER, MPI_RES_SUM(1),MPI_RES_SUM(2),MPI_RES_SUM(3),MPI_RES_SUM(4),MPI_RES_SUM(5),MPI_RES_SUM(6),MPI_RES_SUM(7),MPI_RES_SUM(8)
          END IF
          WRITE(*,*) RESI%RANK,'MAX ERR',IRESM,JRESM,RESMAX
        END IF
        CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
        IF(RESI%RANK.NE.0) THEN
          WRITE(*,*) RESI%RANK,'MAX ERR',IRESM,JRESM,RESMAX        
        END IF
      END IF
      
      IF(RESI%RANK.EQ.0) THEN
        IF(RESI%NPV.EQ.6) THEN
          WRITE(RESI%IO,66) ITER, MPI_RES_SUM(1),MPI_RES_SUM(2),MPI_RES_SUM(3),MPI_RES_SUM(4),MPI_RES_SUM(5),MPI_RES_SUM(6)
        ELSE
          WRITE(RESI%IO,88) ITER, MPI_RES_SUM(1),MPI_RES_SUM(2),MPI_RES_SUM(3),MPI_RES_SUM(4),MPI_RES_SUM(5),MPI_RES_SUM(6),MPI_RES_SUM(7),MPI_RES_SUM(8)
        END IF
      END IF

      IF(RESI%RANK.EQ.0) THEN
        IF(MPI_RES_SUM(1).LT.RESI%BOND) RESI%L_CONVERGE = .TRUE.
      END IF
      
      CALL MPI_BCAST(RESI%L_CONVERGE,1,MPI_LOGICAL,0,MPI_COMM_WORLD,IERR)
      
66  FORMAT(I10,6(F30.12))
88  FORMAT(I10,8(F30.12))
77  FORMAT(I10,2(F30.12)/10X,2(F30.12)/10X,2(F30.12)/10X,2(F30.12))
99  FORMAT(I10,2(F30.12)/10X,2(F30.12)/10X,2(F30.12)/10X,2(F30.12)/10X,2(F30.12))
    END SUBROUTINE RESIDUAL
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
    FUNCTION GETCONVERGE(RESI)
      IMPLICIT NONE
      CLASS(T_RESI), INTENT(IN) :: RESI
      LOGICAL :: GETCONVERGE
      
      GETCONVERGE = RESI%L_CONVERGE
    
    END FUNCTION GETCONVERGE
    !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
END MODULE RESIDUAL_MODULE